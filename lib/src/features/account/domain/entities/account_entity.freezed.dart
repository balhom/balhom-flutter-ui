// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

AccountEntity _$AccountEntityFromJson(Map<String, dynamic> json) {
  return _AccountEntity.fromJson(json);
}

/// @nodoc
mixin _$AccountEntity {
  String get username => throw _privateConstructorUsedError;
  String get email => throw _privateConstructorUsedError;
  bool get receiveEmailBalance => throw _privateConstructorUsedError;
  double get currentBalance => throw _privateConstructorUsedError;
  double get expectedAnnualBalance => throw _privateConstructorUsedError;
  double get expectedMonthlyBalance => throw _privateConstructorUsedError;
  String get locale => throw _privateConstructorUsedError;
  String get prefCurrencyType =>
      throw _privateConstructorUsedError; // ignore: invalid_annotation_target
  @JsonKey(includeIfNull: false)
  String? get image =>
      throw _privateConstructorUsedError; // ignore: invalid_annotation_target
  @JsonKey(includeIfNull: false)
  DateTime? get lastLogin => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountEntityCopyWith<AccountEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountEntityCopyWith<$Res> {
  factory $AccountEntityCopyWith(
          AccountEntity value, $Res Function(AccountEntity) then) =
      _$AccountEntityCopyWithImpl<$Res, AccountEntity>;
  @useResult
  $Res call(
      {String username,
      String email,
      bool receiveEmailBalance,
      double currentBalance,
      double expectedAnnualBalance,
      double expectedMonthlyBalance,
      String locale,
      String prefCurrencyType,
      @JsonKey(includeIfNull: false) String? image,
      @JsonKey(includeIfNull: false) DateTime? lastLogin});
}

/// @nodoc
class _$AccountEntityCopyWithImpl<$Res, $Val extends AccountEntity>
    implements $AccountEntityCopyWith<$Res> {
  _$AccountEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? username = null,
    Object? email = null,
    Object? receiveEmailBalance = null,
    Object? currentBalance = null,
    Object? expectedAnnualBalance = null,
    Object? expectedMonthlyBalance = null,
    Object? locale = null,
    Object? prefCurrencyType = null,
    Object? image = freezed,
    Object? lastLogin = freezed,
  }) {
    return _then(_value.copyWith(
      username: null == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      receiveEmailBalance: null == receiveEmailBalance
          ? _value.receiveEmailBalance
          : receiveEmailBalance // ignore: cast_nullable_to_non_nullable
              as bool,
      currentBalance: null == currentBalance
          ? _value.currentBalance
          : currentBalance // ignore: cast_nullable_to_non_nullable
              as double,
      expectedAnnualBalance: null == expectedAnnualBalance
          ? _value.expectedAnnualBalance
          : expectedAnnualBalance // ignore: cast_nullable_to_non_nullable
              as double,
      expectedMonthlyBalance: null == expectedMonthlyBalance
          ? _value.expectedMonthlyBalance
          : expectedMonthlyBalance // ignore: cast_nullable_to_non_nullable
              as double,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String,
      prefCurrencyType: null == prefCurrencyType
          ? _value.prefCurrencyType
          : prefCurrencyType // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      lastLogin: freezed == lastLogin
          ? _value.lastLogin
          : lastLogin // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AccountEntityImplCopyWith<$Res>
    implements $AccountEntityCopyWith<$Res> {
  factory _$$AccountEntityImplCopyWith(
          _$AccountEntityImpl value, $Res Function(_$AccountEntityImpl) then) =
      __$$AccountEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String username,
      String email,
      bool receiveEmailBalance,
      double currentBalance,
      double expectedAnnualBalance,
      double expectedMonthlyBalance,
      String locale,
      String prefCurrencyType,
      @JsonKey(includeIfNull: false) String? image,
      @JsonKey(includeIfNull: false) DateTime? lastLogin});
}

/// @nodoc
class __$$AccountEntityImplCopyWithImpl<$Res>
    extends _$AccountEntityCopyWithImpl<$Res, _$AccountEntityImpl>
    implements _$$AccountEntityImplCopyWith<$Res> {
  __$$AccountEntityImplCopyWithImpl(
      _$AccountEntityImpl _value, $Res Function(_$AccountEntityImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? username = null,
    Object? email = null,
    Object? receiveEmailBalance = null,
    Object? currentBalance = null,
    Object? expectedAnnualBalance = null,
    Object? expectedMonthlyBalance = null,
    Object? locale = null,
    Object? prefCurrencyType = null,
    Object? image = freezed,
    Object? lastLogin = freezed,
  }) {
    return _then(_$AccountEntityImpl(
      username: null == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      receiveEmailBalance: null == receiveEmailBalance
          ? _value.receiveEmailBalance
          : receiveEmailBalance // ignore: cast_nullable_to_non_nullable
              as bool,
      currentBalance: null == currentBalance
          ? _value.currentBalance
          : currentBalance // ignore: cast_nullable_to_non_nullable
              as double,
      expectedAnnualBalance: null == expectedAnnualBalance
          ? _value.expectedAnnualBalance
          : expectedAnnualBalance // ignore: cast_nullable_to_non_nullable
              as double,
      expectedMonthlyBalance: null == expectedMonthlyBalance
          ? _value.expectedMonthlyBalance
          : expectedMonthlyBalance // ignore: cast_nullable_to_non_nullable
              as double,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String,
      prefCurrencyType: null == prefCurrencyType
          ? _value.prefCurrencyType
          : prefCurrencyType // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      lastLogin: freezed == lastLogin
          ? _value.lastLogin
          : lastLogin // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.snake)
class _$AccountEntityImpl implements _AccountEntity {
  const _$AccountEntityImpl(
      {required this.username,
      required this.email,
      required this.receiveEmailBalance,
      required this.currentBalance,
      required this.expectedAnnualBalance,
      required this.expectedMonthlyBalance,
      required this.locale,
      required this.prefCurrencyType,
      @JsonKey(includeIfNull: false) required this.image,
      @JsonKey(includeIfNull: false) required this.lastLogin});

  factory _$AccountEntityImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountEntityImplFromJson(json);

  @override
  final String username;
  @override
  final String email;
  @override
  final bool receiveEmailBalance;
  @override
  final double currentBalance;
  @override
  final double expectedAnnualBalance;
  @override
  final double expectedMonthlyBalance;
  @override
  final String locale;
  @override
  final String prefCurrencyType;
// ignore: invalid_annotation_target
  @override
  @JsonKey(includeIfNull: false)
  final String? image;
// ignore: invalid_annotation_target
  @override
  @JsonKey(includeIfNull: false)
  final DateTime? lastLogin;

  @override
  String toString() {
    return 'AccountEntity(username: $username, email: $email, receiveEmailBalance: $receiveEmailBalance, currentBalance: $currentBalance, expectedAnnualBalance: $expectedAnnualBalance, expectedMonthlyBalance: $expectedMonthlyBalance, locale: $locale, prefCurrencyType: $prefCurrencyType, image: $image, lastLogin: $lastLogin)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountEntityImpl &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.receiveEmailBalance, receiveEmailBalance) ||
                other.receiveEmailBalance == receiveEmailBalance) &&
            (identical(other.currentBalance, currentBalance) ||
                other.currentBalance == currentBalance) &&
            (identical(other.expectedAnnualBalance, expectedAnnualBalance) ||
                other.expectedAnnualBalance == expectedAnnualBalance) &&
            (identical(other.expectedMonthlyBalance, expectedMonthlyBalance) ||
                other.expectedMonthlyBalance == expectedMonthlyBalance) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.prefCurrencyType, prefCurrencyType) ||
                other.prefCurrencyType == prefCurrencyType) &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.lastLogin, lastLogin) ||
                other.lastLogin == lastLogin));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      username,
      email,
      receiveEmailBalance,
      currentBalance,
      expectedAnnualBalance,
      expectedMonthlyBalance,
      locale,
      prefCurrencyType,
      image,
      lastLogin);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountEntityImplCopyWith<_$AccountEntityImpl> get copyWith =>
      __$$AccountEntityImplCopyWithImpl<_$AccountEntityImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountEntityImplToJson(
      this,
    );
  }
}

abstract class _AccountEntity implements AccountEntity {
  const factory _AccountEntity(
          {required final String username,
          required final String email,
          required final bool receiveEmailBalance,
          required final double currentBalance,
          required final double expectedAnnualBalance,
          required final double expectedMonthlyBalance,
          required final String locale,
          required final String prefCurrencyType,
          @JsonKey(includeIfNull: false) required final String? image,
          @JsonKey(includeIfNull: false) required final DateTime? lastLogin}) =
      _$AccountEntityImpl;

  factory _AccountEntity.fromJson(Map<String, dynamic> json) =
      _$AccountEntityImpl.fromJson;

  @override
  String get username;
  @override
  String get email;
  @override
  bool get receiveEmailBalance;
  @override
  double get currentBalance;
  @override
  double get expectedAnnualBalance;
  @override
  double get expectedMonthlyBalance;
  @override
  String get locale;
  @override
  String get prefCurrencyType;
  @override // ignore: invalid_annotation_target
  @JsonKey(includeIfNull: false)
  String? get image;
  @override // ignore: invalid_annotation_target
  @JsonKey(includeIfNull: false)
  DateTime? get lastLogin;
  @override
  @JsonKey(ignore: true)
  _$$AccountEntityImplCopyWith<_$AccountEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
